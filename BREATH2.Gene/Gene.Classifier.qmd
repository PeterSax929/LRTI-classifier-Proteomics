---
title: "Gene.Classifier"
format: html
toc: true
---



# 1. Import Data

```{r}
#| warning: false




#-------------------------------1a. Import metadata----------------------------#





library(dplyr)
library(magrittr)

data_dir <- "C:/Users/User/Documents/UCSF/BREATH2.Gene/data"
results_dir <- "C:/Users/User/Documents/UCSF/BREATH2.Gene/results"


metadata_df_ALL <- read.csv(
  file.path(data_dir, "sample_metadata.csv"),
  stringsAsFactors=F)

JCI_expanded_metadata <- read.csv(
  file.path(data_dir, "fixed_metadata_10242025.csv"),
  stringsAsFactors=F)

vap_soma_normalized <- read.csv(
  file.path(data_dir, "vap_soma_normalized.csv"),
  stringsAsFactors=F)






#----------------------1b. Ready metadata table for LASSO----------------------#






# Include only the 151 patients with both transcriptomic and proteomic data
patients_vector <- intersect(vap_soma_normalized$patient_id, 
                             JCI_expanded_metadata$SubjectID)

Prot.Data <- vap_soma_normalized[vap_soma_normalized$patient_id %in% patients_vector, ]
Meta.Data <- JCI_expanded_metadata[JCI_expanded_metadata$SubjectID %in% patients_vector, ]


# Ensures rows of Meta.Data match those of Prot.Data
Meta.Data <- Meta.Data[match(Prot.Data$patient_id, Meta.Data$SubjectID), ]

# Produces data frame with patients, age_in_years, sex, and LRTI_Adjudication
patient_info_ALL <- data.frame(
  sample_name = Meta.Data$sanitized_name,
  patient_id = Prot.Data$patient_id,
  sex = Meta.Data$sex,
  age_in_years = Meta.Data$age_in_years,
  LRTI_adjudication = Meta.Data$LRTI_adjudication,
  stringsAsFactors=F
)

# Restrict metadata_df to same 105 patients used in patient_info
metadata_df <- metadata_df_ALL %>%
  filter(sample_name %in% patient_info_ALL$sample_name) %>%
  filter(LRTI_adjudication %in% c("Definite", "No Evidence")) %>%
  left_join(patient_info_ALL %>% select(sample_name, patient_id),
    by = "sample_name") %>%
  relocate(patient_id, .after = sample_name)



# Write csv
write.csv(metadata_df, 
          file.path(data_dir, "metadata_df.csv"), 
          row.names=F)





#------------------------1c. Define workflow parameters------------------------#





# Define parameters
Definite <- table(patient_info_ALL$LRTI_adjudication)["Definite"]
No_Evidence <- table(patient_info_ALL$LRTI_adjudication)["No Evidence"]
npatients <- Definite + No_Evidence
nfolds <- 5
ntrees <- 10000

# Store parameters as data frame
Parameters <- data.frame(c(npatients, Definite, No_Evidence, nfolds, ntrees))
row.names(Parameters) = c("Patients", "Definite", "No Evidence", "Folds", "RF Trees")
colnames(Parameters) = "Count"

write.csv(Parameters,
          file.path(data_dir, "parameters.csv"), 
          row.names=T)






#-----------------------------1d. Safety Check---------------------------------#





print(Parameters)  

nrow(metadata_df)  # should be 105

sum(duplicated(metadata_df$sample_name))  # Should be 0

sum(is.na(Meta.Data$SubjectID))  # Should be 0






```




# 2. Fold Assignment


```{r}
#| warning: false



#-----------------------------2a. Import metadata------------------------------#




library(dplyr)
library(rsample)
library(magrittr)





# Read csvs
metadata_df <- read.csv(
  file.path(data_dir, "metadata_df.csv"), 
  stringsAsFactors=F)

Parameters <- read.csv(
  file.path(data_dir, "parameters.csv"),
  stringsAsFactors=F, row.names=1)



# Number of folds
nfolds <- as.numeric(Parameters["Folds", "Count"])

# Number of No Evidence patients
No_Evidence <- as.numeric(Parameters["No Evidence", "Count"])

# Minimum required per fold
min_NE_per_fold <- floor(No_Evidence / nfolds)






#-------------------------2b. Fold Assignment Using rsample -------------------#





folds_ok <- FALSE

# Set seed
set.seed(8634782)

# While loop enforcing constraints
while (!folds_ok) {

  # Stratified k-fold CV
  vfold_obj <- vfold_cv(
    data = metadata_df,
    v = nfolds,
    strata = "LRTI_adjudication"
  )

  # Add placeholder fold column (will be last column)
  metadata_df_with_folds <- metadata_df %>%
    mutate(fold = NA_integer_)

  # Fill fold assignments
  for (i in seq_len(nfolds)) {
    fold_indices <- vfold_obj$splits[[i]]$in_id
    val_indices <- setdiff(seq_len(nrow(metadata_df)), fold_indices)
    metadata_df_with_folds$fold[val_indices] <- i
  }

  # Count how many No Evidence cases per fold
  counts <- table(
    metadata_df_with_folds$fold,
    metadata_df_with_folds$LRTI_adjudication
  )

  # Check constraint
  if (all(counts[, "No Evidence"] >= min_NE_per_fold)) {
    folds_ok <- TRUE
  }
}

# Save output
write.csv(
  metadata_df_with_folds,
  file.path(data_dir, "metadata_df_with_folds.csv"),
  row.names=F)



#------------------------------2c. Safety Check--------------------------------#



print(counts)

print(min_NE_per_fold)




```







# 3/4. VST / LASSO 

```{r}
#| warning: false





#-----------------------3a. Import host counts & metadata----------------------#





library(dplyr)
library(magrittr)
library(DESeq2)
library(glmnet)
library(tibble)

set.seed(8634782)

# Metadata with folds
metadata_df_with_folds <- read.csv(
  file.path(data_dir, "metadata_df_with_folds.csv"),
  stringsAsFactors=F)

# Host counts (remove gene_symbol col, rownames = ENSG)
host_counts <- read.csv(
  file.path(data_dir, "host_gene_counts.csv"),
  stringsAsFactors=F, row.names = 1)[, -1]

# Filter to samples used for CV
cv_host_counts <- host_counts[, metadata_df_with_folds$sample_name, drop = FALSE]

Parameters <- read.csv(
  file.path(data_dir, "parameters.csv"),
  stringsAsFactors=F, row.names = 1)

nfolds <- as.numeric(Parameters["Folds", "Count"])






#--------------------------------3b. VST Transform-----------------------------#






# Keep genes: >10 counts in >20% samples
keep <- rowSums(cv_host_counts > 10) > 0.2 * ncol(cv_host_counts)
cv_host_counts <- cv_host_counts[keep, ]

# DESeq2 VST
dds <- DESeq2::DESeqDataSetFromMatrix(
  countData = cv_host_counts,
  colData = metadata_df_with_folds,
  design = ~1
)

vsd <- DESeq2::varianceStabilizingTransformation(dds)
vsd_mat <- SummarizedExperiment::assay(vsd) %>% round(2)

# Save VST output
write.csv(
  vsd_mat,
  file.path(data_dir, "cv_vst.csv"),
  row.names=T)






#---------------------------4a. Ready data for LASSO---------------------------#







# Map ENSG → SYMBOL vector
ensg2gene <- read.csv(
  file.path(data_dir, "host_gene_counts.csv"),
  stringsAsFactors=F
) %>%
  { `names<-`(.$gene_symbol, .$X) }

# Prepare X and y
X <- t(as.matrix(vsd_mat))    # samples x genes
y <- metadata_df_with_folds$LRTI_adjudication == "Definite"








#----------------------------4b. LASSO Workflow--------------------------------#







lasso_cv_outer_fold <- function(test_fold) {

  train <- metadata_df_with_folds$fold != test_fold

  # Fit full lambda path
  fit <- glmnet::glmnet(
    X[train, ], y[train],
    family = "binomial",
    standardize = TRUE
  )

  # Count nonzero genes at each lambda
  nz <- apply(fit$beta, 2, function(b) sum(b != 0))

  # Lambda that selects exactly 3 genes
  if (any(nz == 3)) {
    lambda_k3 <- fit$lambda[which(nz == 3)[1]]   # largest lambda w/ 3 nonzero
  } else {
    # fallback: closest to 3, then later trim
    idx <- which.min(abs(nz - 3))
    lambda_k3 <- fit$lambda[idx]
  }

  # Predict
  preds <- predict(fit, X[!train, ], type = "response", s = lambda_k3)[, 1] %>%
    data.frame(pred = .) %>%
    tibble::rownames_to_column("sample_name")

  # Coefficients at selected lambda
  coefs_vec <- coef(fit, s = lambda_k3)[-1, 1]

  nonzero <- coefs_vec[coefs_vec != 0]
  
  
  
  # Ensure at least 3 genes
if (length(nonzero) < 3) {
  # take the strongest remaining coefficients
  coefs_all <- coef(fit, s = lambda_k3)[-1, 1]
  abs_all <- sort(abs(coefs_all), decreasing = TRUE)
  needed <- 3 - length(nonzero)
  add_genes <- names(abs_all)[!names(abs_all) %in% names(nonzero)][1:needed]
  nonzero <- c(nonzero, coefs_all[add_genes])
}


  

  # If >3, keep top 3 by abs value
  if (length(nonzero) > 3) {
    top3 <- sort(abs(nonzero), decreasing = TRUE)[1:3]
    nonzero <- nonzero[names(top3)]
  }
  
  
  
  

  # Build fold-specific coefficient dataframe
  nonzero_df <- data.frame(
    gene = names(nonzero),
    coef = as.numeric(nonzero),
    gene_symbol = ensg2gene[names(nonzero)],
    fold = test_fold, 
    stringsAsFactors=F
  )

  list(pred = preds, mod = fit, coef = nonzero_df)
}





#------------------------4c. Run LASSO across folds----------------------------#







lasso_results <- lapply(
  1:max(metadata_df_with_folds$fold),
  lasso_cv_outer_fold)



# Collect predictions and coefficients for each fold
lasso_preds <- lasso_results %>%
  lapply(function(x) x$pred) %>%
  bind_rows()

lasso_fold_coefs <- lasso_results %>%
  lapply(function(x) x$coef) %>%
  bind_rows()




write.csv(
  lasso_preds,
  file.path(results_dir, "lasso_preds.csv"),
  row.names=F)

write.csv(
  lasso_fold_coefs,
  file.path(results_dir, "lasso_fold_coefs.csv"),
  row.names=F)





#---------------------------4d. Safety Check-----------------------------------#




print(table(lasso_fold_coefs$gene))

nrow(lasso_fold_coefs) == 15 # Should return TRUE

all(rownames(X) == metadata_df_with_folds$sample_name) # Should return TRUE



```
















# 5. Random Forest

```{r}
#| warning: false




#---------------------------5a. Ready Data for RF Workflow---------------------#






library(dplyr)
library(magrittr)
library(randomForest)
library(tibble)

set.seed(8634782)

# Import data
metadata_df_with_folds <- read.csv(
  file.path(data_dir, "metadata_df_with_folds.csv"),
  stringsAsFactors=F)

vsd_mat <- read.csv(
  file.path(data_dir, "cv_vst.csv"),
  row.names = 1,
  check.names = FALSE)

Parameters <- read.csv(
  file.path(data_dir, "parameters.csv"),
  stringsAsFactors=F, row.names=1)

# Define ntrees 
ntrees <- as.numeric(Parameters["RF Trees", "Count"])




# Use transposed version
vsd_mat_t <- t(as.matrix(vsd_mat))

# Convert patient_id to character
metadata_df_with_folds$sample_name <- as.character(metadata_df_with_folds$sample_name)

# Import selected proteins
lasso_fold_coefs <- read.csv(
  file.path(results_dir, "lasso_fold_coefs.csv"), 
  stringsAsFactors=F)

#lasso_fold_coefs_top1_per_fold <- read.csv(
  #file.path(results_dir, "lasso_fold_coefs_top1_per_fold.csv"),
  #stringsAsFactors=F)

#lasso_fold_coefs_top3_per_fold <- read.csv(
  #file.path(results_dir, "lasso_fold_coefs_top3_per_fold.csv"),
  #stringsAsFactors=F)





#-------------------------5b. Choose proteins to run---------------------------#





# Choose which LASSO feature set to use for RF (uncomment ONE line)

# Option 1: All nonzero proteins across folds
selected_lasso_coefs <- lasso_fold_coefs

# Option 2: Top 3 proteins across all folds (Also uncomment the line with ➡️ below)
#selected_lasso_coefs <- lasso_fold_coefs_top3

# Option 3: Top 1 protein per fold
#selected_lasso_coefs <- lasso_fold_coefs_top1_per_fold

# Option 4: Top 3 proteins per fold
#selected_lasso_coefs <- lasso_fold_coefs_top3_per_fold





#-------------------------5c. RF Workflow--------------------------------------#





# Outcome variable
y <- as.factor(metadata_df_with_folds$LRTI_adjudication)  

# Function to run Random Forest for one outer CV fold
lassoRF_cv_outer_fold <- function(test_fold) {
  
  # Extract proteins selected by LASSO for this fold
  keep <- selected_lasso_coefs %>%
            filter(fold == test_fold) %>%
            .$gene
  
  #keep <- lasso_fold_coefs_top3$gene #➡️(uncomment to run global top3)

  # Subset protein matrix to selected proteins; rows = samples, columns = selected proteins
  X <- vsd_mat_t[, keep, drop = FALSE]  
  
  # Boolean for training samples
  train <- metadata_df_with_folds$fold != test_fold
  
  # Fit Random Forest (10000 Trees)
  rf <- randomForest(X[train, , drop = FALSE], y[train], ntree = ntrees)
  
  # Predictions on test fold
  preds <- predict(rf, newdata = X[!train, , drop = FALSE], type = "prob")[, "Definite"]
  
  list(test_fold = test_fold, mod = rf, pred = preds)
}

# Run RF across all folds
cv_list <- lapply(1:max(metadata_df_with_folds$fold), lassoRF_cv_outer_fold)

# Ensure correct format
metadata_df_with_folds <- as.data.frame(metadata_df_with_folds)





#--------------------------5d. Collect preds-----------------------------------#





# Collect out-of-fold predictions for all samples
rf_preds <- cv_list %>%
  lapply(function(x) {
    data.frame(
      sample_name = rownames(vsd_mat_t)[metadata_df_with_folds$fold == x$test_fold],
      pred = x$pred
    )
  }) %>%
  bind_rows() %>%
  dplyr::left_join(
    dplyr::select(metadata_df_with_folds, sample_name, LRTI_adjudication),
    by = "sample_name"
  ) %>%
  dplyr::relocate(LRTI_adjudication, .after = sample_name)

# Save RF predictions
write.csv(rf_preds, 
          file.path(results_dir, "lassoRF_preds.csv"),
          row.names=F)












#------------------------5e. Collect votes-------------------------------------#





# Collect RF votes (training set OOB probabilities)
rf_votes <- cv_list %>%
  lapply(function(x) {
    as.data.frame(x$mod$votes) %>%
      tibble::rownames_to_column("sample_name") %>%
      mutate(test_fold = x$test_fold) %>%
      rename(pred = Definite) %>%
      dplyr::select(test_fold, sample_name, pred)
  }) %>%
  bind_rows() %>%
  dplyr::left_join(
    dplyr::select(metadata_df_with_folds, sample_name, LRTI_adjudication),
    by = "sample_name"
  ) %>%
  dplyr::relocate(LRTI_adjudication, .after = sample_name)

# Save votes
write.csv(rf_votes, 
          file.path(results_dir, "lassoRF_votes.csv"),
          row.names=F)





#------------------------------6f. Safety Check--------------------------------#




# Summary
table(selected_lasso_coefs$gene)


all(selected_lasso_coefs$gene %in% colnames(vsd_mat_t)) # Should return TRUE


nrow(rf_preds) == nrow(metadata_df_with_folds) # Should return TRUE



```













# 6. Generate ROC Graph

```{r}
#| warning: false






#----------------------------6a. Import metadata & preds-----------------------#





library(dplyr)
library(magrittr)
library(pROC)


# Import fold assignments
metadata_df_with_folds <- read.csv(
  file.path(data_dir, "metadata_df_with_folds.csv"),
  stringsAsFactors=F)

# Import out-of-fold predictions
lassoRF_preds <- read.csv(
  file.path(results_dir, "lassoRF_preds.csv"),
  stringsAsFactors=F)

# Ensure consistent factor levels
lassoRF_preds$LRTI_adjudication <- factor(
  lassoRF_preds$LRTI_adjudication,
  levels = c("No Evidence", "Definite")
)

# Merge once so we reuse this everywhere
merged_preds <- lassoRF_preds %>%
  dplyr::inner_join(
    metadata_df_with_folds %>% dplyr::select(sample_name, fold),
    by = "sample_name"
  )





#------------------------6b. Per-fold AUC + ROC plotting-----------------------#






output_auc_roc <- function(preds_df, output_suffix) {

  # Compute per-fold AUC
  auc_df <- preds_df %>%
    group_by(fold) %>%
    summarize({
  roc_obj <- pROC::roc(
    response  = factor(LRTI_adjudication, levels = c("No Evidence", "Definite")),
    predictor = pred,
    direction = "<"
  )
  ci_vals <- pROC::ci.auc(roc_obj, conf.level = 0.95)
  tibble(
    auc = as.numeric(roc_obj$auc),
    auc_lower = ci_vals[1],
    auc_upper = ci_vals[3]
  )
}, .groups = "drop")


  # Determine number of folds
  max_fold <- max(auc_df$fold)

  # Create ROC PDF (all folds overlayed)
  pdf(file.path(results_dir, paste0("ROC_", output_suffix, ".pdf")))

  for (i in 1:max_fold) {
    fold_data <- preds_df %>% filter(fold == i)

    roc_obj <- pROC::roc(
      response  = factor(fold_data$LRTI_adjudication, levels = c("No Evidence", "Definite")),
      predictor = fold_data$pred,
      direction = "<"
    )

    plot(roc_obj, add = (i != 1), col = i)
  }

  dev.off()

  # Save per-fold AUC CSV at the very end (safer if plotting errors occur)
  write.csv(
    auc_df,
    file.path(results_dir, paste0("cv_auc_", output_suffix, ".csv")),
    row.names=F)

  return(auc_df)
}






#------------------------------6c. Plot Graph (in QMD)-------------------------#







# Run AUC computation and PDF creation
auc_lassoRF <- output_auc_roc(merged_preds, "lassoRF")

max_fold <- max(auc_lassoRF$fold)

# Open empty plot for overlay with top-left orientation
plot(0, 0, type = "n",
     xlim = c(1, 0), ylim = c(0, 1),
     xlab = "Specificity", ylab = "Sensitivity",
     main = "ROC Curves by Fold")

# Add diagonal reference
lines(x = c(1, 0), y = c(0, 1), lty = 2, col = "gray")

for (i in 1:max_fold) {
  fold_data <- merged_preds %>% filter(fold == i)

  roc_obj <- pROC::roc(
    response  = factor(fold_data$LRTI_adjudication, levels = c("No Evidence", "Definite")),
    predictor = fold_data$pred,
    direction = "<"
  )

  # Plot specificity directly: axis direction flips via xlim
  lines(roc_obj$specificities, roc_obj$sensitivities, col = i, lwd = 2)
}

legend("bottomright", legend = paste("Fold", 1:max_fold), col = 1:max_fold, lwd = 2)






#------------------------------6d. Summaries----------------------------------#




#Mean AUC / 95% CI for Mean AUC 
#mean_auc <- mean(auc_lassoRF$auc) 

#sd_auc <- sd(auc_lassoRF$auc) 
#n_folds <- nrow(auc_lassoRF) 
#se_auc <- sd_auc / sqrt(n_folds) 

#lower_ci <- mean_auc - qt(0.975, df = n_folds - 1) * se_auc 
#upper_ci <- mean_auc + qt(0.975, df = n_folds - 1) * se_auc 

#message("Lower AUC across folds: ", round(lower_ci, 3)) 
#message("Mean AUC across folds: ", round(mean_auc, 3)) 
#message("Upper AUC across folds: ", round(upper_ci, 3))



# DeLong 95% CI for overall ROC
ci_auc <- pROC::ci.auc(
  pROC::roc(
    response = factor(merged_preds$LRTI_adjudication, levels = c("No Evidence", "Definite")),
    predictor = merged_preds$pred,
    direction = "<"
  ),
  conf.level = 0.95
)

message("Lower AUC: ", round(ci_auc[1], 3))
message("Mean AUC: ", round(as.numeric(ci_auc[2]), 3))
message("Upper AUC: ", round(ci_auc[3], 3))

print(auc_lassoRF)






```







## ROC results

### AUC Values 

lasso_fold_coefs: 0.9301

lasso_fold_coefs_top3: 0.9428

lasso_fold_coefs_top1_per_fold: 0.6705

lasso_fold_coefs_top3_per_fold: 0.8359


