---
title: "Prot.Classifier"
format: html
toc: true
---

# 1. Import Data

```{r}
#| warning: false


#---------------------1a. Import metadata and protein matrix-------------------#



# Set file paths
data_dir <- "C:/Users/User/Documents/UCSF/BREATH2.Prot/data"
results_dir <- "C:/Users/User/Documents/UCSF/BREATH2.Prot/results"

setwd(data_dir)

# Import data from Box
vap_soma_normalized <- read.csv(
  file.path(data_dir, "vap_soma_normalized.csv"), 
  stringsAsFactors=F)

JCI_expanded_metadata <- read.csv(
  file.path(data_dir, "fixed_metadata_10242025.csv"),
  stringsAsFactors=F)



#-------------------------1b. Log2 Transformation------------------------------#



# Log2 Transformation
prot_cols <- grepl("^seq_", names(vap_soma_normalized))

vap_soma_normalized[, prot_cols] <- log2(vap_soma_normalized[, prot_cols])

write.csv(vap_soma_normalized, 
          file.path(data_dir, "vap_soma_normalized_transformed.csv"),
          row.names=F)




#---------------------1c. Build data frame with all patients-------------------#




# Include only the 151 patients in both datasets
patients_vector <- intersect(vap_soma_normalized$patient_id, 
                             JCI_expanded_metadata$SubjectID)

Prot.Data <- vap_soma_normalized[vap_soma_normalized$patient_id %in% patients_vector, ]
Meta.Data <- JCI_expanded_metadata[JCI_expanded_metadata$SubjectID %in% patients_vector, ]

# Ensures rows of Meta.Data match those of Prot.Data
Meta.Data <- Meta.Data[match(Prot.Data$patient_id, Meta.Data$SubjectID), ]

# Produces data frame with patients, age_in_years, sex, and LRTI_Adjudication
patient_info_ALL <- data.frame(
  sample_name = Meta.Data$sanitized_name,
  patient_id = Prot.Data$patient_id,
  sex = Meta.Data$sex,
  age_in_years = Meta.Data$age_in_years,
  LRTI_adjudication = Meta.Data$LRTI_adjudication,
  stringsAsFactors=F
)

write.csv(Meta.Data, 
          file.path(data_dir, "meta.data.csv"),
          row.names=F)

write.csv(Prot.Data, 
          file.path(data_dir, "prot.data.csv"),
          row.names=F)

write.csv(patient_info_ALL, 
          file.path(data_dir, "patient_info_ALL.csv"),
          row.names=F)




#------------------1d. Build protein matrix for all patients-------------------#




# Isolating Protein Matrix (Columns 211:7806 include the 7596 proteins)
protein_mat_PROBEID <- as.matrix(Prot.Data[, prot_cols])

# Remove "seq_"
colnames(protein_mat_PROBEID) <- sub("^seq_", "", colnames(protein_mat_PROBEID))

# Replace underscores with hyphens
colnames(protein_mat_PROBEID) <- gsub("_", "-", colnames(protein_mat_PROBEID))

# Sets rownames to patient_id 
rownames(protein_mat_PROBEID) <- Prot.Data$patient_id

# Write csv
write.csv(protein_mat_PROBEID, 
          file.path(data_dir, "protein_mat_PROBEID.csv"), 
          row.names=T)




#-------------------------------1e. Safety check-------------------------------#



sum(duplicated(Meta.Data$SubjectID)) # Should be 0

length(patients_vector) # Should be 151

all(rownames(protein_mat_PROBEID) == patient_info_ALL$patient_id) # Should be TRUE



```






# 2. Lookup table for proteins

```{r}
#| warning: false


#------------------------------2a. Prepare Seq ids-----------------------------#



library(dplyr)
library(SomaScan.db)
library(SomaDataIO)
library(AnnotationDbi)  
library(tibble)

protein_mat_PROBEID <- read.csv(
  file.path(data_dir, "protein_mat_PROBEID.csv"), 
  stringsAsFactors=F, check.names=F)

# Extracts all PROBEIDs in protein_mat_ALL
seq_ids <- colnames(protein_mat_PROBEID)

# Remove "seq_" and replace underscore with hyphen to match PROBEID keytype
#seq_ids <- sub("^seq_", "", seq_ids)
#seq_ids <- gsub("_", "-", seq_ids)




#----------------------2b. Build protein lookup table--------------------------#



# Build table
protein_lookup_table_ALL <- SomaScan.db::select(
  SomaScan.db,
  keys = seq_ids,
  keytype = "PROBEID",
  columns = c("PROBEID", "SYMBOL", "GENENAME", "UNIPROT")
)

#Remove duplicates
protein_lookup_table_ALL <- protein_lookup_table_ALL %>% distinct(PROBEID, .keep_all=T)




#------------------------2c. Filter Unannotated PROBEIDs-----------------------#




# Removes unannotated PROBEIDs
protein_lookup_table_ALL <- protein_lookup_table_ALL %>%
  filter(!is.na(SYMBOL)) %>%
  arrange(SYMBOL)

# All valid PROBEIDs in the package
valid_ids <- keys(SomaScan.db, keytype = "PROBEID")

# Find unmapped probes
unmapped_probes <- setdiff(seq_ids, valid_ids)


# Write csv
write.csv(data.frame(PROBEID = unmapped_probes), 
          file.path(data_dir, "unmapped_probes.csv"), 
          row.names=F)





#---------------------2d. Take mean expression for PROBEIDs--------------------#






# Keep only annotated probes
protein_mat_PROBEID <- protein_mat_PROBEID[, colnames(protein_mat_PROBEID) %in% protein_lookup_table_ALL$PROBEID]

# Reorder lookup table to match the columns in protein_mat_ALL
protein_lookup_table_ALL <- protein_lookup_table_ALL[match(colnames(protein_mat_PROBEID), protein_lookup_table_ALL$PROBEID), ]

# Confirm alignment
stopifnot(all(colnames(protein_mat_PROBEID) == protein_lookup_table_ALL$PROBEID))

# Collapse duplicate probes (mean expression per SYMBOL)
protein_mat_PROBEID_t <- t(protein_mat_PROBEID) %>%
  as.data.frame() %>%
  mutate(SYMBOL = protein_lookup_table_ALL$SYMBOL) %>%
  group_by(SYMBOL) %>%
  summarise(across(everything(), mean, na.rm=T)) %>%
  as.data.frame()

# Restore to original shape
rownames_tmp <- protein_mat_PROBEID_t$SYMBOL




#--------------------------2e. Align tables------------------------------------#




# Define protein_mat_ALL
protein_mat_ALL <- as.data.frame(t(protein_mat_PROBEID_t[, -1]))
colnames(protein_mat_ALL) <- rownames_tmp
rownames(protein_mat_ALL) <- patients_vector


# Remove duplicate SYMBOLs in lookup table to match collapsed matrix
protein_lookup_table <- protein_lookup_table_ALL %>%
  filter(SYMBOL %in% colnames(protein_mat_ALL)) %>%
  distinct(SYMBOL, .keep_all=T)

# Match lookup table order to protein_mat_ALL column order
protein_lookup_table <- protein_lookup_table[match(colnames(protein_mat_ALL),
                                                   protein_lookup_table$SYMBOL), ]


# Write csvs
write.csv(protein_lookup_table, 
          file.path(data_dir, "protein_lookup_table.csv"),
          row.names=F)

write.csv(protein_mat_ALL, 
          file.path(data_dir, "protein_mat_ALL.csv"), 
          row.names=T)




#------------------------------2f. Safety Check--------------------------------#



length(unmapped_probes)

nrow(protein_lookup_table) # Should be 6346

# Check for duplicate symbols 
any(duplicated(colnames(protein_mat_ALL)))  # Should return FALSE

# Confirm lengths match
length(colnames(protein_mat_ALL))  # Should be 6346
length(protein_lookup_table$SYMBOL)  # SHould be 6346

# How many symbols actually overlap
sum(colnames(protein_mat_ALL) %in% protein_lookup_table$SYMBOL)  # Should be 6346



```



# 3. Organize Data and Parameters


```{r}
#| warning: false


#-----------------3a. Subset both datasets to Definite/No Evidence-------------#




# Read csvs
protein_lookup_table <- read.csv( 
          file.path(data_dir, "protein_lookup_table.csv"),
          stringsAsFactors=F)

protein_mat_ALL <- read.csv( 
          file.path(data_dir, "protein_mat_ALL.csv"), 
          stringsAsFactors=F, row.names=1)

# Include only Definite and No Evidence patients
patient_info <- patient_info_ALL[patient_info_ALL$LRTI_adjudication %in% 
                                     c("Definite", "No Evidence"), ]

# Includes only the protein matrix for Definite and No Evidence patients
protein_mat <- protein_mat_ALL[match(patient_info$patient_id, 
                                       rownames(protein_mat_ALL)), ]

# Save outputs
write.csv(patient_info, 
          file.path(data_dir, "patient_info.csv"),
          row.names=F)

write.csv(protein_mat,
          file.path(data_dir, "protein_mat.csv"),
          row.names=T)




#-------------------------3b. Define Workflow Parameters-----------------------#





# Define parameters
Definite <- table(patient_info$LRTI_adjudication)["Definite"]
No_Evidence <- table(patient_info$LRTI_adjudication)["No Evidence"]
npatients <- nrow(patient_info)
nproteins <- ncol(protein_mat)
nfolds <- 5
ntrees <- 10000

# Store parameters as data frame
Parameters <- data.frame(c(npatients, Definite, No_Evidence, nproteins, nfolds, ntrees))
row.names(Parameters) = c("Patients", "Definite", "No Evidence", "Proteins", "Folds", "RF Trees")
colnames(Parameters) = "Count"

# Write csv
write.csv(Parameters, 
          file.path(data_dir, "parameters.csv"),
          row.names=T)

print(Parameters)



#-----------------------------3c. Safety Check---------------------------------#





# Ensures that protein_mat rownames match patient_id column in patient_info
all(rownames(protein_mat) == patient_info$patient_id)  # Should return TRUE

any(is.na(match(patient_info$patient_id, 
                rownames(protein_mat_ALL))))  # Should return FALSE

# Ensures that protein_mat rownames match patient_id column in patient_info
all(rownames(protein_mat) == patient_info$patient_id)  # Should return TRUE






```

  
  
  
# 4. Fold Assignments


```{r}
#| warning: false


#------------------------4a. Import patient info-------------------------------#



library(dplyr)
library(rsample)




# Read csvs
patient_info <- read.csv(
  file.path(data_dir, "patient_info.csv"), 
  stringsAsFactors=F)

Parameters <- read.csv(
  file.path(data_dir, "parameters.csv"),
  stringsAsFactors=F, row.names=1)

# Define number of folds
nfolds <- as.numeric(Parameters["Folds", "Count"])

# Define number of No Evidence patients
No_Evidence <- as.numeric(Parameters["No Evidence", "Count"])

# Minimum required per fold
min_NE_per_fold <- floor(No_Evidence / nfolds)








#------------------------4b. Fold Assignment Using rsample --------------------#






# Retry until constraints satisfied
folds_ok <- FALSE

# Set seed to 8634782 = "BREATH2" .. kinda?
set.seed(8634782)

# While loop
while (!folds_ok) {

  # Stratified vfold_cv using rsample
  vfold_obj <- vfold_cv(
    data = patient_info,
    v = nfolds,
    strata = "LRTI_adjudication"
  )

  # Create a data frame that maps each row to a fold
  patient_info_with_folds <- patient_info %>%
    mutate(fold = NA_integer_)

  # Fill in fold assignments
  for (i in seq_len(nfolds)) {
    fold_indices <- vfold_obj$splits[[i]]$in_id
    # everything *not* in fold_indices is validation fold
    val_indices <- setdiff(seq_len(nrow(patient_info)), fold_indices)
    patient_info_with_folds$fold[val_indices] <- i
  }

  # Check constraint: minimum No Evidence per fold
  counts <- table(
    patient_info_with_folds$fold,
    patient_info_with_folds$LRTI_adjudication
  )

  if (all(counts[, "No Evidence"] >= min_NE_per_fold)) {
    folds_ok <- TRUE
  }
}

# Save
write.csv(
  patient_info_with_folds,
  file.path(data_dir, "patient_info_with_folds.csv"),
  row.names=F)







#--------------------------------4c. Safety Check------------------------------#






print(counts)

print(min_NE_per_fold)






```
Note: 33 no evidence patients creates one fold with a 14:7 definite ratio. This differs more than the 15:7 and 14:6 ratios for 32 no evidence patients





# 5. Run LASSO


```{r}

#| warning: false



#-----------------------5a. Ready data for LASSO Workflow----------------------#




library(dplyr)
library(magrittr)
library(glmnet)
library(tibble)

set.seed(8634782)

# Import data
patient_info_with_folds <- read.csv(
  file.path(data_dir, "patient_info_with_folds.csv"),
  stringsAsFactors=F)

protein_mat <- read.csv(
  file.path(data_dir, "protein_mat.csv"),
  stringsAsFactors=F, row.names=1, check.names=F)

Parameters <- read.csv(
  file.path(data_dir, "parameters.csv"),
  stringsAsFactors=F, row.names=1)


# Define nfolds
nfolds <- as.numeric(Parameters["Folds", "Count"])

# Prepare inputs for LASSO
X <- as.matrix(protein_mat)  
y <- patient_info_with_folds$LRTI_adjudication == "Definite"





#--------------------------5b. LASSO Workflow----------------------------------#





# Function to extract nonzero coefficients
lasso_coef_df <- function(mod) {
  coefs <- coef(mod, s = "lambda.1se")[, 1]
  coefs <- coefs[-1]  # remove intercept
  
  nonzero <- coefs[coefs != 0]
  
  if(length(nonzero) < 3){
    abs_coefs <- abs(coefs)
    top3 <- sort(abs_coefs, decreasing = TRUE)[1:3]
    nonzero <- coefs[names(top3)]
  }
  
  data.frame(protein = names(nonzero), coef = as.numeric(nonzero))
}

# Function for a single outer CV fold
lasso_cv_outer_fold <- function(test_fold) {
  train <- patient_info_with_folds$fold != test_fold
  foldid <- sample(rep(1:nfolds, length.out = sum(train)))

  
  mod <- glmnet::cv.glmnet(
    X[train, ], y[train],
    family = "binomial",
    foldid = foldid
  )
  
  preds <- predict(mod, X[!train, ], type = "response", s = "lambda.1se")[, 1] %>%
    data.frame(pred = .) %>%
    tibble::rownames_to_column("sample_name")
  
  nonzero <- lasso_coef_df(mod) %>%
    mutate(fold = test_fold)
  
  list(pred = preds, mod = mod, coef = nonzero)
}

# Run LASSO across all folds
lasso_results <- lapply(1:max(patient_info_with_folds$fold), lasso_cv_outer_fold)

# Combine predictions and coefficients
lasso_preds <- lasso_results %>%
  lapply(function(x) x$pred) %>%
  bind_rows()

lasso_fold_coefs <- lasso_results %>%
  lapply(function(x) x$coef) %>%
  bind_rows()

# Merge SYMBOL-based annotations directly
lasso_fold_coefs <- merge(
  lasso_fold_coefs,
  protein_lookup_table,
  by.x = "protein",
  by.y = "SYMBOL",
  all.x = TRUE
)




#----------------5c. Define lasso_fold_coefs multiple ways---------------------#





# Top 3 by absolute coefficient
#lasso_fold_coefs_top3 <- lasso_fold_coefs %>%
  #group_by(protein) %>%                       
  #slice_max(abs(coef), n = 1) %>%             
  #ungroup() %>%                               
  #arrange(desc(abs(coef))) %>%                
  #slice(1:3)      


# Select top 1 per fold
lasso_fold_coefs_top1_per_fold <- lasso_fold_coefs %>%
  group_by(fold) %>%
  slice_max(order_by = abs(coef), n = 1, with_ties = FALSE) %>%
  ungroup()

# Select top 3 per fold
lasso_fold_coefs_top3_per_fold <- lasso_fold_coefs %>%
  group_by(fold) %>%
  slice_max(order_by = abs(coef), n = 3, with_ties = FALSE) %>%
  ungroup()




# Save outputs
write.csv(lasso_preds, 
          file.path(results_dir, "lasso_preds.csv"), 
          row.names=F)

write.csv(lasso_fold_coefs,
          file.path(results_dir, "lasso_fold_coefs.csv"),
          row.names=F)

#write.csv(lasso_fold_coefs_top3, 
          #file.path(results_dir, "lasso_folds_coefs_top3.csv"),
          #row.names=F)

write.csv(lasso_fold_coefs_top1_per_fold,
          file.path(results_dir, "lasso_fold_coefs_top1_per_fold.csv"),
          row.names=F)

write.csv(lasso_fold_coefs_top3_per_fold,
          file.path(results_dir, "lasso_fold_coefs_top3_per_fold.csv"),
          row.names=F)




#----------------------------5d. Safety Check----------------------------------#



# Summary
print(table(lasso_fold_coefs$protein))

all(lasso_fold_coefs$protein %in% 
      protein_lookup_table$SYMBOL)  # Should return TRUE



```





# 6. Implement RF


```{r}
#| warning: false



#----------------------------6a. Ready Data for RF Workflow--------------------#




library(dplyr)
library(magrittr)
library(randomForest)
library(tibble)

set.seed(8634782)

# Import data
patient_info_with_folds <- read.csv(
  file.path(data_dir, "patient_info_with_folds.csv"),
  stringsAsFactors=F)

protein_mat <- read.csv(
  file.path(data_dir, "protein_mat.csv"), 
  stringsAsFactors=F, row.names=1, check.names=F)

Parameters <- read.csv(
  file.path(data_dir, "parameters.csv"),
  stringsAsFactors=F, row.names=1)

# Define ntrees 
ntrees <- as.numeric(Parameters["RF Trees", "Count"])


# Convert patient_id to character
patient_info_with_folds$patient_id <- as.character(patient_info_with_folds$patient_id)

# Import selected proteins
lasso_fold_coefs <- read.csv(
  file.path(results_dir, "lasso_fold_coefs.csv"), 
  stringsAsFactors=F)

lasso_fold_coefs_top1_per_fold <- read.csv(
  file.path(results_dir, "lasso_fold_coefs_top1_per_fold.csv"),
  stringsAsFactors=F)

lasso_fold_coefs_top3_per_fold <- read.csv(
  file.path(results_dir, "lasso_fold_coefs_top3_per_fold.csv"),
  stringsAsFactors=F)





#-------------------------6b. Choose proteins to run---------------------------#






# Choose which LASSO feature set to use for RF (uncomment ONE line)

# Option 1: All nonzero proteins across folds
selected_lasso_coefs <- lasso_fold_coefs

# Option 2: Top 3 proteins across all folds (ALso uncomment the line with ➡️ below)
#selected_lasso_coefs <- lasso_fold_coefs_top3

# Option 3: Top 1 protein per fold
#selected_lasso_coefs <- lasso_fold_coefs_top1_per_fold

# Option 4: Top 3 proteins per fold
#selected_lasso_coefs <- lasso_fold_coefs_top3_per_fold





#-------------------------6c. RF Workflow--------------------------------------#






# Outcome variable
y <- as.factor(patient_info_with_folds$LRTI_adjudication)  

# Function to run Random Forest for one outer CV fold
lassoRF_cv_outer_fold <- function(test_fold) {
  
  # Extract proteins selected by LASSO for this fold
  keep <- selected_lasso_coefs %>%
            filter(fold == test_fold) %>%
            .$protein
  
  #keep <- lasso_fold_coefs_top3$protein #➡️(uncomment to run global top3)

  # Subset protein matrix to selected proteins; rows = samples, columns = selected proteins
  X <- protein_mat[, keep, drop = FALSE]  
  
  # Boolean for training samples
  train <- patient_info_with_folds$fold != test_fold
  
  # Fit Random Forest (10000 Trees)
  rf <- randomForest(X[train, , drop = FALSE], y[train], ntree = ntrees)
  
  # Predictions on test fold
  preds <- predict(rf, newdata = X[!train, , drop = FALSE], type = "prob")[, "Definite"]
  
  list(test_fold = test_fold, mod = rf, pred = preds)
}

# Run RF across all folds
cv_list <- lapply(1:max(patient_info_with_folds$fold), lassoRF_cv_outer_fold)

# Ensure correct format
patient_info_with_folds <- as.data.frame(patient_info_with_folds)





#--------------------------6d. Collect preds-----------------------------------#





# Collect out-of-fold predictions for all samples
rf_preds <- cv_list %>%
  lapply(function(x) {
    data.frame(
      patient_id = rownames(protein_mat)[patient_info_with_folds$fold == x$test_fold],
      pred = x$pred
    )
  }) %>%
  bind_rows() %>%
  dplyr::left_join(dplyr::select(patient_info_with_folds, patient_id, LRTI_adjudication), 
            by = "patient_id") %>%
  dplyr::relocate(LRTI_adjudication, .after = patient_id)

# Save RF predictions
write.csv(rf_preds, 
          file.path(results_dir, "lassoRF_preds.csv"),
          row.names=F)






#------------------------6e. Collect votes-------------------------------------#






# Collect RF votes (training set OOB probabilities)
rf_votes <- cv_list %>%
  lapply(function(x) {
    as.data.frame(x$mod$votes) %>%
      tibble::rownames_to_column("patient_id") %>%
      mutate(test_fold = x$test_fold) %>%
      rename(pred = Definite) %>%
      dplyr::select(test_fold, patient_id, pred)
  }) %>%
  bind_rows() %>%
  dplyr::left_join(dplyr::select(patient_info_with_folds, patient_id, LRTI_adjudication), 
            by = "patient_id") %>%
  dplyr::relocate(LRTI_adjudication, .after = patient_id)

# Save votes
write.csv(rf_votes, 
          file.path(results_dir, "lassoRF_votes.csv"),
          row.names=F)






```






# 7. Generate ROC Graph

```{r}
#| warning: false






#----------------------------7a. Import metadata & preds-----------------------#





library(dplyr)
library(magrittr)
library(pROC)


# Import fold assignments
patient_info_with_folds <- read.csv(
  file.path(data_dir, "patient_info_with_folds.csv"),
  stringsAsFactors=F)

# Import out-of-fold predictions
lassoRF_preds <- read.csv(
  file.path(results_dir, "lassoRF_preds.csv"),
  stringsAsFactors=F)

# Ensure consistent factor levels
lassoRF_preds$LRTI_adjudication <- factor(
  lassoRF_preds$LRTI_adjudication,
  levels = c("No Evidence", "Definite")
)

# Merge once so we reuse this everywhere
merged_preds <- lassoRF_preds %>%
  dplyr::inner_join(
    patient_info_with_folds %>% dplyr::select(patient_id, fold),
    by = "patient_id"
  )





#------------------------7b. Per-fold AUC + ROC plotting-----------------------#






output_auc_roc <- function(preds_df, output_suffix) {

  # Compute per-fold AUC
  auc_df <- preds_df %>%
    group_by(fold) %>%
    summarize(
      auc = as.numeric(
        pROC::roc(
          response  = factor(LRTI_adjudication, levels = c("No Evidence", "Definite")),
          predictor = pred,
          direction = "<"
        )$auc
      )
    ) %>%
    ungroup()

  # Determine number of folds
  max_fold <- max(auc_df$fold)

  # Create ROC PDF (all folds overlayed)
  pdf(file.path(results_dir, paste0("ROC_", output_suffix, ".pdf")))

  for (i in 1:max_fold) {
    fold_data <- preds_df %>% filter(fold == i)

    roc_obj <- pROC::roc(
      response  = factor(fold_data$LRTI_adjudication, levels = c("No Evidence", "Definite")),
      predictor = fold_data$pred,
      direction = "<"
    )

    plot(roc_obj, add = (i != 1), col = i)
  }

  dev.off()

  # Save per-fold AUC CSV at the very end (safer if plotting errors occur)
  write.csv(
    auc_df,
    file.path(results_dir, paste0("cv_auc_", output_suffix, ".csv")),
    row.names=F)

  return(auc_df)
}






#------------------------------7c. Plot Graph (in QMD)-------------------------#







# Run AUC computation and PDF creation
auc_lassoRF <- output_auc_roc(merged_preds, "lassoRF")

max_fold <- max(auc_lassoRF$fold)

# Open empty plot for overlay with top-left orientation
plot(0, 0, type = "n",
     xlim = c(1, 0), ylim = c(0, 1),
     xlab = "Specificity", ylab = "Sensitivity",
     main = "ROC Curves by Fold")

# Add diagonal reference
lines(x = c(1, 0), y = c(0, 1), lty = 2, col = "gray")

for (i in 1:max_fold) {
  fold_data <- merged_preds %>% filter(fold == i)

  roc_obj <- pROC::roc(
    response  = factor(fold_data$LRTI_adjudication, levels = c("No Evidence", "Definite")),
    predictor = fold_data$pred,
    direction = "<"
  )

  # Plot specificity directly: axis direction flips via xlim
  lines(roc_obj$specificities, roc_obj$sensitivities, col = i, lwd = 2)
}

legend("bottomright", legend = paste("Fold", 1:max_fold), col = 1:max_fold, lwd = 2)






#------------------------------7d. Summaries----------------------------------#





print(auc_lassoRF)

mean_auc <- mean(auc_lassoRF$auc)
message("Mean AUC across folds: ", round(mean_auc, 3))





```








## ROC results

### AUC Values 

lasso_fold_coefs: 0.919

lasso_fold_coefs_top1_per_fold: 0.756

lasso_fold_coefs_top3_per_fold: 0.905



















